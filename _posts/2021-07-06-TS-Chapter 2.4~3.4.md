---
title: "[토비의 스프링] Week3(2.4~3.4)"
subtitle: 토비의 스프링 3주차
date: 2021-07-06 22:38:24 +0900
author: taxol
toc: 
categories: 토비의_스프링
tags:
  - 토비의_스프링
toc: true
toc_sticky: true
---

> 토비의 스프링 3.1 Chapter 2.4 ~ 3.4

# Chapater 2.4

기존 UserTestDao의 문제 :

- @Before 메소드가 테스트 메소드 개수 만큼 반복되기 때문에 애플리케이션 컨텍스트도 3번 만들어진다.
- 빈이 많아지고 복잡해지면 애플리케이션 컨텍스트 생성에 적지 않은 시간이 걸릴 수 있다.

해결 :

- 애플리케이션 오브젝트를 테스트 전체가 공유하는 오브젝트로 만들자!

## @BeforeClass

여러 테스트가 참조할 애플리케이션 컨텍스트를 **스태틱 필드**에 저장하기 위해 테스트 클래스 전체에 걸쳐 딱 한번만 실행되는 **@BeforeClass** 스태틱 메소드를 사용할 수 있다.

-> But, 스프링이 직접 제공하는 애플리케이션 컨텍스트 테스트 지원 기능이 더 효율적

## Spring Test Context FrameWork

여러 테스트 오브젝트가 사용하는 ApplicationContext를 인스턴스 변수로 선언하고 **@Autowired** 어노테이션을 붙혀 자동 DI가 되도록 한다.

```java
RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/applicationContext.xml")	// 자동으로 만들어줄 ApplicationContext 위치 지정
public class UserDaoTest {

	@Autowired
	private ApplicationContext context;

	@Before
	public void setUp() {
		this.dao = context.getBean("userDao", UserDao.class);
		...
	}
```

### @Autowired

@Autowired는 Spring DI에서 사용되는 특별한 어노테이션이다.  
일반적으로 주입을 위해서는 생성자나, 수정자가 필요하지만, 이 경우에는 메소드 없이도 주입이 가능하다. 이를 `타입에 의한 자동 와이어링` 이라한다.

@Autowired가 붙은 인스턴스 변수가 있으면, test context framework는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾아, 일치하면 인스턴스 변수로 주입해준다.

- 참고로 Spring Application Context는 초기화 할 때 자기 자신도 빈으로 등록하기 때문에 ApplicationContext 타입의 빈이 주입이 가능한 것이다.

```java
public class UserDaoTest {
    @Autowired
    UserDao userDao;
    ...
}
```

어플리케이션 컨텍스트가 가지고 있는 빈을 DI 받을 수 있다면 굳이 getBean()을 이용하지 않고 UserDao 빈을 받을 수 있다.

## DI와 Test

> 우리는 절대로 DataSource의 구현 클래스를 바꾸지 않을 것이다
> 따라서 굳이 Datasource 인터세이스를 사용하고 DI를 통해 주입을 받아아햘까?

**그럼에도 불구하고 인터페이스를 두고 DI를 적용해야한다**

- 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없기 때문  
  언젠간 구현 클래스가 바뀔 수도 있다.
- 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입 가능  
  1장에서 만든 DB 커넥션 개수를 카운팅 하는 부가기능이 그런 예
- Test 용이성  
  DI는 테스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는데 중요한 역할을 한다.

## 테스트 코드에 의한 DI

테스트를 위해 DB를 조작한다고 생각하자.  
만약 운영 중인 DB를 건들였다가 큰일 나기 때문에 DB연결을 바꿀 필요가 있다.

따라서, DI를 이용해 테스트 중 DAO가 사용하는 DataSource 구현 클래스를 바꿔주는 방법으로 운영 DB와 테스트 DB를 분리할 수 있다.

```java
@DirtiesContext
public class UserDaoTest {
    @Autowired
    UserDao userDao;

    @Before
    public void setUp() {
        ...
        DataSource dataSource = new SingleConnectionDataSource(
                "jdbc:mysql://localhost/testdb", "spring", "book", true
        );
        userDao.setDataSource(dataSource);
    }
}
```

이 방법으로 XML 설정파일 변경없이 테스트 코드를 통해 오브젝트 관계를 재구성 할 수 있다.

하지만 위 방식은 매우 주의하여야 하는데,  
애플리케이션 컨텍스트는 테스트 중에 딱 한개만 만들어지 고 모든 테스트에서 공유하여 사용한다.  
따라서, 이미 애플리케이션에서 applicationContext.xml 파일의 설정정보에 따라 구성한 오브젝트를 강제로 변경하면 나머지 모든 테스트를 수행하는 동안 변경된 애플리케이션 컨텍스트가 사용된다.

따라서, **@DirtiesContext** 어노테이션을 사용하여, 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 에플리케이션 컨텍스트의 상태를 변경한다는 것을 알려주고 애플리케이션 컨텍스트의 공유를 허용하지 않는다고 말한다.

### xml 설정 파일 변경을 통한 별도의 DI 설정

테스트 코드에서 빈 오브젝트를 수동으로 DI 하는 방법은 장점보다 단점이 많다. 코드가 많아져 번거롭기도 하고 애플리케이션 컨텍스트를 매번 만들어야 하는 부담이 있다.

이 문제는 applicationContext.xml 을 복사해 text-applicationContext.xml 을 만들어 운영으로 사용할 DataSource 와 테스트에 적합하게 준비된 DB를 사용하는 가벼운 DataSource 를 빈으로 등록하여 테스트에서는 항상 테스트 전용 설정파일만 사용하게 해줌으로써 해결할 수 있다.

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "/test-applicationContext.xml")
public class UserDaoTest {
    ...
}
```

이로써 번거롭게 수동 DI 하는 코드나 @DirtiesContext 가 필요 없어졌다.
