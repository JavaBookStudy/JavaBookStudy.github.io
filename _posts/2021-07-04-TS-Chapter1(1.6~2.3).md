---
title: "[토비의 스프링] Week1(1.1~1.5)"
subtitle: 토비의 스프링 1주차
date: 2021-06-27 13:59:24 +0900
author: integer
toc: 
categories: 토비의_스프링
tags:
  - 토비의_스프링
toc: true
toc_sticky: true
---

# 토비의 스프링 3.1 1장~2장 1.6~2.3

# 1.6 싱글톤 레지스트리와 오브젝트 스코프

## 오브젝트의 동일성(identical)과 동등성(equivalent)

### 동일성(Identical)

```java
String s1 = new String("고길동");
String s2 = new String("고길동");

s1 == s2; // false; 두 스트링 객체는 담고있는 값이 같을 뿐 동일한 객체는 아니다.
```

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/01bfe5b2-a1ff-4ace-8056-f692a6a0dab2/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/01bfe5b2-a1ff-4ace-8056-f692a6a0dab2/Untitled.png)

두 객체가 완전히 동일한 객체라면 동일한(identical) 객체라고 할 수 있다. s1==s1은 참이지만, s1==s2는 거짓이다.

### 동등성

```java
String s1 = new String("고길동");
String s2 = new String("고길동");

s1.equals(s2); // true; 
// Java String 객체의 동등성 비교는 각 스트링 객체가 실질적으로 담고있는
// 문자열이 같다면 동등하다고 하며 우리의 직관에도 배치되지 않는다.
```

두 객체의 동등성 조건 - 각 객체에 구현된 equals메서드에는 무엇이 같아야 두 객체가 동등한지를 구현해놓았다. 두 객체는 동일하지 않더라도 동등할 수 있으며, 두 객체가 동일하면 동등하다.

[자세히 살펴보기 : Effective Java ITEM 10. equals는 일반 규약을 지켜 재정의 하라](https://daebalprime.tistory.com/entry/Effective-Java-3E-3%EC%9E%A5-%EB%AA%A8%EB%93%A0-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EA%B3%B5%ED%86%B5-%EB%A9%94%EC%84%9C%EB%93%9C)

## 싱글톤(Singleton) 패턴

싱글톤 패턴은 어떤 클래스를 어플리케이션 내에서 제한된 갯수의 인스턴스 갯수를 갖도록 하는 패턴이며, 이름에서 유추할 수 있듯이 일반적으로 단 하나의 오브젝트만 존재한다.

전역에서 하나의 인스턴스를 공유해야 하는 경우에 이 패턴을 사용한다.

싱글턴 패턴을 Java에서 구현하려면

- 생성자를 private로 지정하여 외부에서 새 인스턴스를 만들지 못하도록 한다.
- static 필드에 인스턴스를 담을 수 있는 변수를 하나 정의한다.
- static factory method인 getInstance()를 만들고 메서드가 최초로 호출되는 시점에 오브젝트를 만들어 static 필드의 변수에 저장한다.
- getInstance() 메서드는 static 필드에 저장된 인스턴스를 반환한다. 호출될 때 마다 static 필드에 저장된 단 하나의 인스턴스를 반환하므로 싱글톤 패턴이다.

그러나 싱글턴 패턴은

- private 생성자는 상속을 제한한다.
- 테스트하기 힘들다.

    직접 인스턴스를 만들 수 없기 때문에 테스트가 힘들다.

- 서버환경에서는 싱글톤이 단 하나임을 보장하지 못한다.

    서버에서 클래스 로더를 어떻게 구성하냐에 따라 static 변수는 단 하나임이 보장되지 않는다. 예를 들면 다수의 JVM에서 분산되어 돌아가는 경우가 있다.

- 전역 상태의 특성은 바람직하지 않다.

    객체지향 프로그래밍에서 전역 상태는 권장되지 않는 모델이다.

## 스프링에서의 싱글톤

지금까지 작성한 DaoFactory 코드는 userDao() 메서드를 호출할 때 마다 새로운 객체를 반환한다.

그러나 스프링 Application Context에 설정정보를 등록하고 getBean() 메서드로 가져오는 userDao() 메서드는 항상 동일한 인스턴스를 반환한다. 그래서 Application Context에 이르러 싱글톤 레지스트리(Singleton Registry)라고 하기도 한다.

스프링은 주로 서버환경에서 사용된다. 서버에는 다양한 계층의 오브젝트가 있다. 비즈니스 로직, 서비스 로직, DAO 등등... 그러나 이를 담당하는 객체들을 매 요청마다 생성한다면? 한 번의 요청에 10개의 객체를 생성한다면, 500번의 요청에는 5000개의 객체가 생성될 것인데 GC가 바쁘게 돌아가고 성능 저하는 피할 수 없을 것이다. 그래서 자바 엔터프라이즈에서는 서비스 오브젝트라는 개념이 일찍부터 고안되었다. 엔터프라이즈의 핵심이자 기반인 서블릿에서는 싱글톤으로 멀티쓰레드 환경에서 동작한다.

### 싱글톤 레지스트리

위에서 언급했던 것 처럼 Java의 싱글톤 구현의 정석은 여러 문제가 있기 때문에, 스프링에서 싱글톤 오브젝트를 생성하고 관리하는 기능을 제공하는 요소를 싱글톤 레지스트리라고 한다. 싱글톤 레지스트리는 평범한 자바 객체도 싱글톤으로 활용할 수 있도록 해준다. 어노테이션을 붙여 스프링 컨테이너에게 제어권을 넘기면 알아서 다 해준다.

### 싱글톤과 오브젝트의 상태

싱글톤은 멀티쓰레드 환경에서 여러 쓰레드가 접근할 수 있으므로, stateless 방식으로 만들어져야 한다.  만약 인스턴스 필드를 두고 값을 유지하며 동작에 관여하도록 stateful 하게 만들면 race condition에 의해 서버가 망가질 것이다. 

**Code #10 : stateful한 UserDao**

```java
public class UserDao {
	private ConnectionMaker connectionMaker; 
	// 생성자가 한 번 설정하면 후에 바뀔 일이 없는 읽기전용 인스턴스 변수.
  // connectionMaker는 스프링이 관리하는 빈이고, 싱글톤이기 때문에
	// 다른 ConnectionMaker 타입의 인스턴스가 할당될 일이 없다.
  // 물론 final 키워드로 지정해 주는 편이 좋을 것이다.
  // 요약 : 싱글톤 빈을 저장하는 인스턴스 변수는 문제가 되지 않는다.

	private Connection c;
	private User user;
	// 각 요청마다 고유한 객체를 담고 있어야 할 필드가 인스턴스 변수로 선언이되면
  // race condition이 발생한다.
	public User get(String id) throws ClassNotFoundException, SQLException {
		this.c = connectionMaker.makeConnection();

		this.user = new User(); 
		this.user.setId(rs.getString("id")); 
		/*
		 * this.user 변수로 접근하여 조작하는 와중에 
		 * 다른 쓰레드가 this.user를 덮어 씌우게 된다면?
		 */

		//...

		return this.user;
	}
}
```

stateless하게 만들면 정보는 어떻게 다뤄야 할까? 파라미터와 리턴 값, 로컬 변수 등을 이용하면 thread-safe함을 보장할 수 있다.

### 스프링 빈의 스코프

스프링 빈이 생성되고 존재하고 적용되는 범위를 스코프라고 한다. 스프링 빈의 default 스코프는 싱글톤이며, 컨테이너 내에 한 개의 오브젝트만 만들어진다. 만약 Bean을 요청할 때 마다 새로은 인스턴스를 만들도록 하고 싶다면 prototype 스코프를 고려할 수 있다. 그 외에도 매 요청마다 생성되는 request 스코프, 웹의 세션에 대응하는 session 스코프도 있다. 

# 1.7 의존관계 주입(DI)

IoC는 객체지향 패러다임에서 중요하게 여겨지는 개념으로, DaoFactory처럼 객체를 생성하고 관계를 맺어주는 등의 작업을 담당하는 기능을 일반화한 것이 스프링의 IoC 컨테이너다.

스프링을 IoC 컨테이너로 부르기에는 단순한 템플릿 메서드 패턴을 이용해 만들어진 프레임워크,인지, 서블릿처럼 동작하는 서비스 컨테이너 뜻인지 이해하기 어렵기 때문에 스프링의 IoC 방식을 의존관계 주입(Dependency Injection)이라 부른다. 런타임에 의존관계가 정해진다는 의도를 담고 있다.

### 의존관계

두 개의 클래스가 있다. A가 B를 의존한다면 B의 변화가 A에 영향을 미친다는 의미이다. A가 B의 메서드를 사용하는 경우가 ㄷ대표적이다. 사용에 대한 의존관계가 있다고 말할 수 있다. B의 메서드 시그니쳐가 바뀌거나 내부 동작이 바뀌면 A의 코드를 수정해야하거나 결과에 영향이 미칠 수 있다. UML 모델에선 점선으로 표기하며, 아래 그림을 참조하면 된다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/522c9e12-8416-4963-8ea3-c01e00dfb724/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/522c9e12-8416-4963-8ea3-c01e00dfb724/Untitled.png)

UserDao의 경우에는, ConnectionMaker 인터페이스에 의존하고 있다. 그러나 인터페이스를 구현한 클래스가 다른 것으로 바뀌거나 인터페이스에 정의된 메서드가 아닌 내부에서 사용하는 메서드에 변화가 생겨도 UserDao는 동작할 것이다. 인터페이스에 의존하면 그 구현 클래스와의 관계는 느슨해지며 변화에 영향을 많이 받지 않는다.  UserDao 입장에선 구현 클래스의 존재를 알지 못한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bb56b8de-e88f-49d5-8ed5-32239ecf9785/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bb56b8de-e88f-49d5-8ed5-32239ecf9785/Untitled.png)

### 의존관계 주입

UML에서 의존관계는 설계 모델의 관점에서 이야기하는 것이다. 모델이나 코드에서 드러나는 의존관계 이외에도 런타임에 오브젝트 사이에서 만들어ㅏ지는 의존 관계를 런타임 의존관계라 부르며, 위에서 다뤘던 설계 모델의 관점에서 의존 관계가 구체화된다고 볼 수 있다. 런타임에 의존관계를 맺는 오브젝트를 **의존 오브젝트**라고 한다. 

구체적인 의존 오브젝트와 클라이언트 오브젝트를 연결해주는 작업을 **의존관계 주입**이라고 부른다. UserDao가 DConnectionMaker 인스턴스를 인터페이스를 통해 받아들이는 경우이다.

의존관계 주입은 다음 세 가지 조건을 따른다.

- 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 즉 어떤 구현 클래스를 쓰는지 UserDao 코드에선 알 수 없으며 인터페이스에만 의존하고 있는 상태이다.
- 런타임 시점의 의존관계는 컨테이너나 팩토리와 같은 **제3의 존재**가 결정한다.
- 이 외부 주체가 실질적으로 사용할 오브젝트를 주입/제공하는 시점에 의존관계가 만들어진다.

이 제 3의 존재는 Application Context, Bean Factory, IoC 컨테이너 등이다. 

**Code #11 : 의존관계 주입을 적용한 생성자**

```java
public UserDao(ConnectionMaker connectionMaker){
		this.connectionMaker = connectionMaker; 
		// 자신이 사용할 오브젝트는 생성자 파라미터를 통해서 전달받는다.
}
```

주의해야 할 점은 외부에서 오브젝트를 파라미터로 전달해주었다고 해서 의존관계 주입은 아니다. 반드시 인터페이스 타입으로 전달해주어야 한다.

### 의존관계 검색

외부로 주입을 받지 않고 스스로 검색하여 의존관계를 맺는 의존관계 검색(Dependency Lookup)도 있다. 자신이 사용할 구체적인 클래스를 지목하지는 않지만, 컨테이너에게 요청한다. 

**Code #12 : 의존관계 검색을 이용하는 생성자**

```java
public UserDao(){
		AnnotationConfigApplicationContext context = 
				new AnnotationConfigApplicationContext(DaoFactory.class);
		this.connectionMaker = context.getBean("connectionMaker", ConnectionMaker.class);

}
```

ApplicationContext에 "connectionMaker" 이름을 가진 Bean을 요청한다. 해당 이름을 가진 Bean을 직접 생성하지는 않기 때문에 여전히 IoC 원칙을 준수한다.

### 의존관계 주입 vs 검색

일반적으로는 의존관계 주입을 사용하는 것이 깔끔하다. 의존관계 검색은 스프링 API나 팩토리 클래스에 의존하게 된다. 

그러나 의존관계 검색을 사용해야 할 때가 있다. 스프링 IoC와 DI 컨테이너가 적용되어 있지만 한 번은 반드시 의존관계 검색을 수행해야 한다. 엔트리 포인트인 main()에서는 DI로 주입받을 방법이 없기 때문이다. 또한 의존관계 검색을 구현한 클래스는 자기 자신이 스프링의 Bean일 필요가 전혀 없다. ConnectionMaker는 스프링의 Bean이여야 하지만, UserDao는 그렇지 않아도 된다는 소리이다. 그 반대로 의존관계 주입에서는 UserDao도 반드시 Spring이 관리하는 Bean이 되어야 한다. 

### DI의 장점은 무엇일까?

앞에서 설명한 원칙과 객체지향 설계를 따랐을 때 얻는 이점들을 그대로 얻을 수 있다. 코드에는 의존하는 클래스가 구체적으로 나타나지 않아 결합도가 낮기  때문에 변경을 통한 확장에 자유롭다.

**시나리오 1. 데이터베이스 교체하기**

배포 시에는 실제 데이터베이스 서버를 이용해야겠지만, 개발할 때는 개발자 로컬의 데이터베이스를 이용하는 것이 일반적이다. DI를 적용한 코드에서는 이 변경이 빠르고 자유롭다. 예를 들면, ConnectionMaker.connectionMaker()에서 반환하는 오브젝트만 수정하면 끝이다.

**시나리오 2. 부가기능 추가**

DAO가 DB에 얼마나 자주 연결하는지 파악하고 싶다고 해보자. 개발하다보면 DAO의 종류가 많아질 텐데 그 모든 코드에 커넥션을 호출할 때 마다 카운트를 증가시키는 로직을 추가한다면 손이 많이 가겠지만, 실제 ConnectionMaker 구체 클래스와 인터페이스 사이에 하나의 오브젝트를 더 끼워넣고, 카운트하는 로직을 추가하는게 다일 것이다.

**Code #13 : 연결 횟수를 Counting하는 ConnectionMaker 구체 클래스**

```java
import java.sql.Connection;
import java.sql.SQLException;

public class CountingConnectionMaker implements ConnectionMaker {
	
	int counter = 0;
	private ConnectionMaker realConnectionMaker;

	public CountingConnectionMaker(ConnectionMaker realConnectionMaker) {
		this.realConnectionMaker = realConnectionMaker; 
		// 실제 사용될 ConnectionMaker 구체클래스를 받는다.
	}

	@Override
	public Connection makeConnection() throws ClassNotFoundException, SQLException {
		this.counter++; 
		return realConnectionMaker.makeConnection();
		// 실제 오브젝트를 반환하기 전에 counter를 한 번 증가시켜준다.
	}

	public int getCounter() {
		return this.counter;
	}
}
```

### 스프링에서 사용하는 메서드 이용 의존관계 주입

지금까지 예제에서는 의존관계 주입에 생성자 파라미터를 이용했지만, 일반적으로 스프링에선 setter 메서드를 통한 DI를 사용했다. 자바 빈 규격을 따르기 때문에 나중에 사용하기 편하다.

메서드 이름은 의미있고 단순한 이름이 제일 좋지만 특별한 아이디어가 없다면 메서드를 통해 주입받을 오브젝트 타입이름을 붙이는 게 제일 좋다. setConnectionMaker()가 그 예다.

# 1.8 XML을 이용한 설정

스프링 DI 의존관계 설정하는 방법은 XML과 Annotation 크게 2가지가 있다. 그 중 XML은

1. 단순한 텍스트 파일로 수정이 용이
2. 쉽게 이해 가능
3. 변경사항 발생 시 재컴파일하지 않아도 됨
4. 빠르게 변경사항 반영 가능
5. 스키마나 DTD를 이용해 정해진 포맷을 따라 작성되었는지 검사 가능 (문법 검사)

과 같은 장점을 가지고 있다.

### XML 설정하기

스프링의 Application Context는 XML에 담긴 DI정보를 활용할 수 있다. 이 XML을 작성할 때 루트 엘리먼트를 <beans>로 두고 작성해 나가면 된다.

어노테이션으로 작성한 하나의 @Bean 메소드에서 얻을 수 있는 빈의 DI 정보는

- 빈의 이름 : @Bean 메소드 이름으로 지정이 되며, getBean()에서 사용하는 이름
- 빈의 클래스 : 빈 오브젝트를 어떤 클래스를 이용해서 만들지를 정의
- 빈의 의존 오브젝트 : 빈의 생성자나 수정자 메소드를 통해 의존 오브젝트를 주입하는데, 주입하는 오브젝트 또한 빈일 것이고 이름으로 가져온다. 여러 개에 의존할 수도 있음

[클래스 - XML 설정 1:1 대응](https://www.notion.so/34e5423054ec4311aca597de5be67c55)

기존 클래스에 작성된 정보를 XML로 1:1 대응하면 된다. 주의할 점은, 빈의 클래스 항목에 작성하는 내용은 반환하고자 하는 실제 구체 클래스이며, 인터페이스를 작성하지 않도록 하자. 또한 패키지 경로를 모두 작성하여야 한다.

**Code #14 : 메서드 → XML 전환 예시**

```java
@Bean //----------------------------------->  <bean
public ConnectionMaker{
    connectionMaker(){ //------------------> id="connectionMaker
        return new DConnectionMaker(); // -> class="springbook...DConnectionMaker" />
    }
}

<bean id="connectionMaker class="springbook...DConnectionMaker"/>
```

### 의존 관계를 주입받는 Bean 설정하기

앞에서 작성한 userDao는 connectionMaker 의존을 주입받는다. 스프링은 자바빈을 관례를 따라서 setter 메서드를 프로퍼티로 사용한다. 즉 setConnectionMaker()라는 메서드를 정의해 놓으면 set을 제외한 ConnectionMaker라는 프로퍼티 이름으로 사용한다.

XML에서는 <property> 태그를 이용해 의존 관계를 정의한다. name과 ref라는 두 개의 애트리뷰트를 갖는다. name은 프로퍼티의 이름이고, ref는  주입해줄 오브젝트 빈의 이름이다. 

**Code #15 : 메서드 → XML 의존주입 전환**

```java
userDao.setConnectionMaker(connectionMaker());
        ___|______________ _______________
				 /     \                    \
 _______/       \______________      \_______________
<property name="connectionMaker" ref="connectionMaker" />
```

주의해야 할 점은, setter 메서드는 Java의 컨벤션인 Camel Case를 따라 C가 대문자이지만, xml에 작성할 때도 set을 제외한 부분에서 첫 글자는 소문자로 작성해 주어야 한다.

**Code #16 : userDao 빈 설정 마치기**

```xml
<bean id ="userDao" class="{classpath....}.UserDao">
	<property name="connectionMaker" ref="connectionMaker" />
</bean>
```

**Code #17 : XML 완성**

```xml
<beans>
	<bean id="connectionMaker class="springbook...DConnectionMaker"/>
	<bean id ="userDao" class="{classpath....}.UserDao">	
		<property name="connectionMaker" ref="connectionMaker" />
	</bean>
</beans>
```

### ApplicationContext 설정하기

XML 빈의 의존관계 정보를 이용하는 DI에는 GenericXmlApplicationContext를 사용한다. ApplicationContext가 사용하는 파일은 applicationContext.xml로 만드는게 컨벤션이다. 

**Code #18 : applicationContext.xml 예시**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id="connectionMaker class="springbook...DConnectionMaker"/>
	<bean id ="userDao" class="{classpath....}.UserDao">	
		<property name="connectionMaker" ref="connectionMaker" />
	</bean>
</beans>
```

**Code #19 : ApplicationContext 불러오기**

```java
ApplicationContext context = new GenericXmlApplicationContext("{path}/applicationContext.xml");
ApplicationContext context = new ClassPathApplicationContext("daoContext.xml", UserDao.class);
//UserDao 패키지가 위치한 클래스패스를 가져와 상대경로를 지정할 수 있다.

```

### DataSource 인터페이스 적용

ConnectionMaker는 DB 커넥션 생성 딱 하나만 당당하는 인터페이스다. Java에서는 DB 커넥션을 가져오는 오브젝트의 기능을 담은 DataSource라는 인터페이스가 존재한다. 이에 맞춰 구현된 클래스들을 사용하는 것으로 충분하다.

jdbc 라이브러리를 추가하자.

**Code #20 : DataSource** 

```java
package javax.sql
 
public interface DataSource extends CommonDataSource, Wrapper{
    Connection getConnction() throws SQLException;
		// 커넥션을 가져오는 메서드인 getConnection() 사용
		//...
}
 
import javax.sql.DataSource;
 
public class UserDao{
    private DataSource dataSource;
 
    public void setDataSource(DataSource dataSource){
        this.dataSource = dataSource;
    }
 
    public void add(User user) throws SQLException{
        Connection c = dataSource.getConnction();
        //...
    }
    //...
}
```

**Code #21 : 자바 코드로 url, id, pw 설정하기**

```java
@Bean 
public DataSource dataSource(){
    SimpleDriverDataSource dataSource = new SimpleDriverDataSource();
 
    dataSource.setDriverClass(com.mysql.jdbc.Driver.class);
    dataSource.setUrl("jdbc:mysql://localhost/springbook");
    dataSource.setUsername("myid");
    dataSource.setPassword("mypw");
 
    return dataSource;
}

@Bean 
public UserDao userDao(){
    UserDao userDao = new UserDao();
    userDao.setDataSource(dataSource()); // DataSource를 주입받는다.
    return userDao;
}
```

**Code #21 : XML로 로그인 정보, url 설정하기**

```xml
<bean id="dataSource"
    class="org.springframework.jdbc.datasource.SimpleDriverDataSource" />
	<property name="driverClass" value="com.mysql.jdbc.Driver" />
	<!--
		driver class는 java.lang.Class를 받도록 되어있지만 value는 String 값이다.
		스프링이 파라미터 타입을 참고해서 적당히 추론하여 변환해준다.
		내부적으론 아래와 같은 작업을 해준다고 생각하면 된다.
		Class driverClass = Class.forName("com.mysql.jdbc.Driver");
		dataSource.setDriverClass(driverClass);
	-->
	<property name="url" value="jdbc://localhost/springbook" />
	<property name="username" value="myid" />
	<property name="password" value="mypw" />
</bean>
```

### Reference

[토비의 스프링 예제코드 by icednut](https://github.com/icednut/st-toby-spring)

[토비의 스프링 - 1장 오브젝트와 의존관계 by wan-blog (다이어그램 스캔본 출처)](https://wan-blog.tistory.com/27)
