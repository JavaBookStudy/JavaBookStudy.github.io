---
title: "[토비의 스프링] Week4(3.5~3.7)"
subtitle: 토비의 스프링 4주차
date: 2021-07-17 13:44:24 +0900
author: jth2747
toc: 
categories: 토비의_스프링
tags:
  - 토비의_스프링
toc: true
toc_sticky: true
---

> 토비의 스프링 3.1 Chapter 3.5 ~ 3.7

# Chapater 3.5 템플릿과 콜백

템플릿/콜백 패턴

- 전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식
  - 템플릿: 전략 패턴의 컨텍스트
  - 콜백: 익명 내부 클래스로 만들어지는 오브젝트

## 3.5.1 템플릿/콜백의 동작원리
- 고정된 작업 흐름을 가진 코드를 재사용한다는 의미의 **템플릿** 내부에서 **콜백** 오브젝트가 호출되면서 동작

### 템플릿/콜백의 특징  
- 콜백은 보통 단일 메소드 인터페이스를 사용
  - 특정 기능을 위해 한 번 호출되는 경우가 일반적
  - 하나 이상 사용할 수도 있음
- 콜백의 파라미터
  - 템플릿 내부에서 만들어지는 컨텍스트 정보를 전달받을 때 사용
- DI 방식의 전략 패턴 구조
  - 클라이언트가 템플릿 메소드를 호출, 콜백 오브젝트를 전달하는 것은 메소드 레벨에서 일어나는 DI
  - T/C 방식에서는 매번 메소드 단위로 사용할 오브젝트를 새롭게 전달받음
  - 콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조

## 3.5.2 편리한 콜백의 재활용

- 익명 내부 클래스 때문에 코드를 작성하고 읽기가 조금 불편

### 콜백의 분리와 재활용
```java
  public void deleteAll() throws SQLExecption {
    this.jdbcCOntext.workWithStatementStrategy(
      new StatementStrategy() {
        public PreparedStatement makePreparedStatement(Connention c) throws SQLExecption {
          return c.prepareStatement("delete from users");
        }
      }
    )
  }
```
- 익명 클래스 내부의 SQL 문장은 계속 변할 수 있다.
```java
  public void deleteAll() throws SQLException {
      executeSql("delete from users");
  }
```
```java
  private void executeSql(final String query) throws SQLException {
      jdbcContext.workWithStatementStrategy(new StatementStrategy() {
          @Override
          public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
              PreparedStatement ps = c.prepareStatement(query);
              return ps;
          }
      });
  }
```
- 변하지 않는 부분을 분리
- 재활용 가능한 콜백을 담아냄

### 콜백과 템플릿의 결합
- executeSql() 메소드는 UserDao 뿐만 아니라 다른 DAO에서 사용될 수 있다
- 템플릿은 JdbcContext 클래스가 아니라 그 내부의 workWithStatementStrategy 메소드이므로 jdbcContext 클래스로 excuteSql 메소드를 옮기는 것이 좋다
```java
  public void deleteAll() throws SQLException {
      this.jdbcContext.executeSql("delete from users");
  }
```
```java
  public class JdbcContext {
    ...
    public void executeSql(final String query) throws SQLException {
        workWithStatementStrategy(new StatementStrategy() {
            @Override
            public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
                PreparedStatement ps = c.prepareStatement(query);
                return ps;
            }
        });
    }
    ...
  }
```
- executeSql을 JdbcContext 내부로 옮기고 접근이 가능하게 public으로 수정
- UserDao 메소드에서도 jdbcCOntext를 통해 executeSql 메소드를 호출하도록 수정
- 하나의 목적을 위해 서로 긴밀하게 연관되어 동작하는 응집력이 강한 코드들은 한 군데 모여있는 게 유리

## 3.5.3 템플릿/콜백의 응용
- 스프링은 템플릿/콜백 패턴을 적극적으로 활용하는 프레임워크
- 고정 된 작업 흐름을 갖고 있으면서 반복되는 코드가 있다면, 분리할 방법을 생각해보는 습관을 길러보자
- 템플릿/콜백 패턴의 주요 대상 - try/catch/finally를 사용하는 코드
- 책의 calcSum() 코드 참고

### 중복의 제거와 템플릿/콜백 설계
- 추가 요구사항이 들어오면? 코드 복붙?? X
- 템플릿/콜백 패턴 적용
  - 템플릿에 담을 반복되는 작업 흐름 정하기
  - 템플릿 to 콜백, 콜백 to 템플릿 각각 전달해야 할 내용이 무엇인지 파악
- BufferedReader을 전달받아 결과값 돌려주는 콜백 적용 (3-35)
- 추가 요구사항에 따라 곱셈 기능도 수행하는 콜백 메서드 생성

### 템플릿/콜백의 재설계
- 곱셈 콜백 메서드와 덧셈 콜백 메서드는 공통되는 부분이 존재
- 계산한 값을 넘겨주는 콜백 인터페이스 생성
- 그 콜백을 사용하는 템플릿 생성
- 템플릿을 사용하도록 곱셈과 덧셈 메소드를 수정 (결과값을 return 해주는 방식)

### 제네릭스를 이용한 콜백 인터페이스
- 결과 타입을 Integer뿐만 아니라 다양한 타입으로 받고 싶다면?
```java
public <T> T lineReadTemplate(String numbersFilePath, LineCallback<T> callback, T initValue) throws IOException {
  BufferedReader br = null;
  try {
    br = new BufferedReader(new FileReader(numbersFilePath));
    T resultValue = initValue;
    String line = null;
    while ((line = br.readLine()) != null) {
      resultValue = callback.doSomethingWithLine(line, resultValue);
    }
    return resultValue;
  } catch (IOException e) {
    System.out.println(e.getMessage());
    throw e;
  } finally {
    if (br != null) {
      try {
      br.close();
      } catch (IOException e) {
        System.out.println(e.getMessage());
      }
    }
  }
}
```
- 타입 파라미터 T를 갖는 인터페이스 LineCallback
- T 타입의 초기값 initValue를 받아서 T 타입 변수 resultValue를 정의
- T 타입으로 선언된 LineCallBack 메소드 호출해서 처리하고 T 타입의 결과를 리턴하는 메소드